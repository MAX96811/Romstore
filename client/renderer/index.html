<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RomStore Library</title>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&family=Space+Mono:wght@400;700&display=swap');

:root {
  --bg-color: #080808;
  --bg-elev: #0f0f0f;
  --bg-panel: #121212;
  --card-bg: #141414;
  --card-border: #232323;
  --text-color: #f4f4f4;
  --text-dim: #9a9a9a;
  --text-soft: #c8c8c8;
  --accent: #ff6600;
  --accent-soft: #ff8a3d;
  --accent-glow: rgba(255, 102, 0, 0.35);
  --btn-bg: #ff6600;
  --btn-text: #111111;
  --success: #33d17a;
  --error: #ff5f5f;
  --shadow-lg: 0 20px 48px rgba(0, 0, 0, 0.5);
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 18px;
}

* { box-sizing: border-box; }

html, body { min-height: 100%; }

body {
  margin: 0;
  color: var(--text-color);
  font-family: 'Inter', sans-serif;
  background:
    radial-gradient(circle at 15% -10%, rgba(255, 102, 0, 0.16), transparent 35%),
    radial-gradient(circle at 95% 5%, rgba(255, 102, 0, 0.10), transparent 30%),
    linear-gradient(180deg, #0b0b0b 0%, #070707 100%);
  overflow-x: hidden;
}

::selection { background: var(--accent); color: #fff; }

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(24px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes pulseGlow {
  0%, 100% { box-shadow: 0 0 0 rgba(255, 102, 0, 0); }
  50% { box-shadow: 0 0 24px var(--accent-glow); }
}

@keyframes toastIn {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

header {
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 20px 36px;
  border-bottom: 1px solid #1d1d1d;
  background: rgba(8, 8, 8, 0.92);
  backdrop-filter: blur(8px);
}

.header-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
}

h1 {
  margin: 0;
  color: var(--accent);
  text-transform: uppercase;
  font-size: clamp(1.6rem, 2.6vw, 2.2rem);
  letter-spacing: 0.08em;
  font-weight: 900;
}

#current-user-label,
#lib-mode {
  color: var(--text-dim) !important;
  font-family: 'Space Mono', monospace;
}

.tabs {
  display: flex;
  align-items: center;
  gap: 10px;
}

.tabs button {
  border: 1px solid #242424;
  background: #101010;
  color: var(--text-dim);
  font-family: 'Space Mono', monospace;
  font-size: 0.82rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  border-radius: 999px;
  padding: 9px 16px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.tabs button:hover {
  color: #fff;
  border-color: #3a3a3a;
  transform: translateY(-1px);
}

.tabs button.active {
  color: #fff;
  border-color: var(--accent);
  background: linear-gradient(180deg, #29180c, #1a120d);
  box-shadow: inset 0 0 0 1px rgba(255, 102, 0, 0.25);
}

.controls {
  width: 100%;
  padding-top: 12px;
  border-top: 1px solid #1e1e1e;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.filter-group {
  display: flex;
  align-items: center;
  gap: 9px;
  max-width: 58%;
  overflow-x: auto;
  padding-bottom: 5px;
}

.filter-group::-webkit-scrollbar { height: 5px; }
.filter-group::-webkit-scrollbar-thumb { background: #2c2c2c; border-radius: 999px; }

.filter-chip {
  border: 1px solid #262626;
  background: #111111;
  color: var(--text-dim);
  font-family: 'Space Mono', monospace;
  font-size: 0.75rem;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  border-radius: 999px;
  padding: 6px 12px;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.2s ease;
}

.filter-chip:hover { color: #fff; border-color: #3b3b3b; }

.filter-chip.active {
  color: #fff;
  background: #1c120c;
  border-color: var(--accent);
  box-shadow: inset 0 0 0 1px rgba(255, 102, 0, 0.25);
}

.view-options {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

select,
.toggle-btn,
#search-filter,
input[type='text'],
input[type='password'],
.input-group input,
.input-group select {
  background: #111111;
  color: #fff;
  border: 1px solid #2a2a2a;
  border-radius: var(--radius-sm);
  padding: 8px 12px;
  font-size: 0.9em;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

select:focus,
.toggle-btn:focus,
#search-filter:focus,
input[type='text']:focus,
input[type='password']:focus,
.input-group input:focus,
.input-group select:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(255, 102, 0, 0.2);
}

.toggle-btn.active {
  color: #fff;
  border-color: var(--accent);
  background: #1a120d;
}

.content-area { padding: 34px; }

.section-header {
  margin: 28px 0 18px;
  padding-bottom: 8px;
  color: #fff;
  font-family: 'Space Mono', monospace;
  font-size: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  border-bottom: 1px solid #232323;
  animation: fadeInUp 0.35s ease both;
}

.section-header:first-child { margin-top: 0; }

.library-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(204px, 1fr));
  gap: 24px;
}

.game-card {
  position: relative;
  display: flex;
  flex-direction: column;
  cursor: pointer;
  animation: fadeInUp 0.28s ease both;
}

.game-card:hover { transform: translateY(-3px); }

.art-wrapper {
  position: relative;
  width: 100%;
  padding-top: 140%;
  overflow: hidden;
  border-radius: var(--radius-md);
  background: linear-gradient(165deg, #171717 0%, #101010 100%);
  border: 1px solid var(--card-border);
  box-shadow: var(--shadow-lg);
}

.game-art {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.icon-placeholder {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 60px;
  color: #ddd;
  background: radial-gradient(circle at 30% 20%, #252525, #121212 55%);
}

.card-overlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(180deg, rgba(12, 12, 12, 0.15) 8%, rgba(8, 8, 8, 0.95) 72%);
  padding: 16px;
  opacity: 0;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  transition: opacity 0.2s ease;
}

.game-card.active .card-overlay { opacity: 1; pointer-events: auto; }

.overlay-info { margin-bottom: 16px; }

.overlay-system {
  color: var(--accent);
  font-size: 0.76rem;
  font-family: 'Space Mono', monospace;
  text-transform: uppercase;
  letter-spacing: 0.07em;
  margin-bottom: 6px;
}

.overlay-meta {
  color: var(--text-soft);
  opacity: 0.88;
  font-size: 0.82rem;
  margin-top: 3px;
}

.download-btn,
.action-btn,
.action-btn-small {
  border: 1px solid var(--accent);
  background: var(--btn-bg);
  color: var(--btn-text);
  border-radius: 9px;
  padding: 9px 15px;
  font-weight: 800;
  text-decoration: none;
  cursor: pointer;
  letter-spacing: 0.02em;
  transition: transform 0.15s ease, filter 0.15s ease;
}

.download-btn:hover,
.action-btn:hover,
.action-btn-small:hover {
  transform: translateY(-1px);
  filter: brightness(1.05);
}

.game-title-below {
  margin-top: 11px;
  color: #fff;
  font-size: 0.92rem;
  font-weight: 700;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 4px;
}

.edit-btn {
  position: absolute;
  top: 9px;
  right: 9px;
  z-index: 10;
  width: 30px;
  height: 30px;
  border: 1px solid #3b3b3b;
  border-radius: 999px;
  background: rgba(12, 12, 12, 0.85);
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}

.modal {
  position: fixed;
  inset: 0;
  z-index: 220;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(4, 4, 4, 0.84);
}

.modal-content {
  width: 540px;
  max-width: 95%;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: var(--radius-lg);
  border: 1px solid #2a2a2a;
  background:
    radial-gradient(circle at 88% -10%, rgba(255, 102, 0, 0.12), transparent 28%),
    linear-gradient(180deg, #121212 0%, #0d0d0d 100%);
  color: #f0f0f0;
  padding: 22px;
  box-shadow: var(--shadow-lg);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
  font-family: 'Space Mono', monospace;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.close-btn {
  color: #bbb;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
}
.close-btn:hover { color: #fff; }

.input-group { margin-bottom: 12px; }
.input-group label { display: block; margin-bottom: 6px; color: #ddd; font-size: 0.86rem; }

.results-list { margin-top: 14px; display: grid; gap: 9px; }
.result-item {
  border: 1px solid #292929;
  border-radius: 10px;
  background: #121212;
  padding: 9px;
  display: flex;
  gap: 12px;
  align-items: center;
}
.result-img { width: 56px; height: 56px; object-fit: cover; border-radius: 6px; }
.result-title { font-weight: 700; color: #fff; }
.result-year { color: #aaa; font-size: 0.85rem; }

.version-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #222;
  padding: 11px 6px;
}

.version-info { color: #d2d2d2; font-size: 0.9rem; }

.library-list { display: flex; flex-direction: column; gap: 9px; }

.game-row {
  display: flex;
  align-items: center;
  gap: 14px;
  border: 1px solid #232323;
  border-radius: 12px;
  background: #111111;
  padding: 10px;
  transition: border-color 0.2s ease, transform 0.2s ease;
}

.game-row:hover { border-color: #343434; transform: translateY(-1px); }
.game-row.active { border-color: var(--accent); animation: pulseGlow 1.4s ease-in-out infinite; }

.game-row .row-thumb { width: 62px; height: 62px; object-fit: cover; border-radius: 8px; background: #151515; }
.game-row .row-info { flex: 1; min-width: 0; }
.game-row .row-title { font-size: 1rem; font-weight: 700; color: #fff; }
.game-row .row-meta { display: flex; gap: 9px; color: #aaa; font-size: 0.82rem; flex-wrap: wrap; }
.game-row .row-actions { display: flex; align-items: center; gap: 8px; }

.progress-container, .progress-bar-bg {
  width: 100%;
  height: 7px;
  border-radius: 999px;
  background: #252525;
  overflow: hidden;
}

.progress-bar,


.progress-container { display: none; }
.downloading .progress-container { display: block; }

.progress-label {
  margin-bottom: 6px;
  font-family: 'Space Mono', monospace;
  color: #cbcbcb;
  display: flex;
  justify-content: space-between;
  font-size: 0.78rem;
}

.toast {
  position: fixed;
  right: 18px;
  bottom: 18px;
  min-width: 250px;
  z-index: 320;
  border-radius: 10px;
  border: 1px solid #343434;
  border-left: 4px solid var(--accent);
  background: #101010;
  color: #fff;
  padding: 12px 14px;
  box-shadow: var(--shadow-lg);
  animation: toastIn 0.24s ease;
}

.conflict-item {
  border: 1px solid #2b2b2b;
  border-radius: 12px;
  background: #111111;
  padding: 13px;
  display: flex;
  flex-direction: column;
  gap: 9px;
}

.conflict-title {
  border-bottom: 1px solid #252525;
  padding-bottom: 7px;
  color: #fff;
  font-weight: 700;
}

.conflict-compare {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 10px;
}

.conflict-side { flex: 1; }
.conflict-side.local { border-right: 1px solid #282828; padding-right: 12px; }
.conflict-side.cloud { text-align: right; padding-left: 12px; }

.c-label {
  color: #a9a9a9;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  font-size: 0.73rem;
  margin-bottom: 4px;
}

.c-date { color: #f0f0f0; font-family: 'Space Mono', monospace; font-size: 0.82rem; }

.c-badge {
  display: inline-block;
  margin-top: 6px;
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 0.69rem;
  font-weight: 700;
}

.c-newer { background: rgba(51, 209, 122, 0.2); color: #9ef1c5; border: 1px solid rgba(51, 209, 122, 0.35); }
.c-older { background: rgba(255, 95, 95, 0.2); color: #ffb1b1; border: 1px solid rgba(255, 95, 95, 0.35); }

.conflict-actions { display: flex; justify-content: center; gap: 10px; margin-top: 8px; }

#resolve-all-local,
#resolve-all-cloud {
  color: #fff !important;
  border-width: 1px !important;
  border-style: solid !important;
}

#resolve-all-local {
  background: #27445a !important;
  border-color: #355c79 !important;
}

#resolve-all-cloud {
  background: #2f5b3f !important;
  border-color: #3e7954 !important;
}

#resolve-all-local:hover,
#resolve-all-cloud:hover { filter: brightness(1.08); }

@media (max-width: 900px) {
  header { padding: 16px; }
  .header-top { align-items: flex-start; flex-direction: column; }
  .controls { align-items: stretch; }
  .filter-group { max-width: 100%; }
  .view-options { width: 100%; }
  .content-area { padding: 18px; }
  .library-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 16px; }
}
</style>
</head>
<body>
<header>
    <div class="header-top">
        <img src="LOGO.png" alt="ROMSTORE" style="height: 50px; width: auto;">
        <div style="display:flex; gap: 15px; align-items: center;">
            <button id="logout-btn" class="action-btn" style="background:transparent; border: 1px solid #f44336; color: #f44336;">Logout</button>
            <button id="open-settings-btn" class="action-btn" style="background:transparent; border: 1px solid #444; color: #9e9e9e;">‚öô Settings</button>
            <nav class="tabs">
                <button id="tab-games" class="active">Games</button>
                <button id="tab-bios">Bios</button>
            </nav>
        </div>
        <div style="color: #9e9e9e; font-size: 0.9em;" id="lib-mode">Library Mode: Native</div>
    </div>
    <div class="controls">
        <div class="filter-group" id="filter-container"></div>
        <div class="view-options">
            <input type="text" id="search-filter" placeholder="Search files...">
            <label style="font-size: 0.85em; display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none;">
                <input type="checkbox" id="installed-only-filter"> Installed
            </label>
            <select id="sort-select"><option value="name_asc">Name (A-Z)</option><option value="name_desc">Name (Z-A)</option><option value="date_new">Date Added (Newest)</option><option value="date_old">Date Added (Oldest)</option></select>
            <button id="view-toggle" class="toggle-btn" title="Toggle Grid/List">‚äû / ‚ò∞</button>
            <button id="group-toggle" class="toggle-btn">Group by Console</button>
        </div>
    </div>
</header>
<div id="main-content" class="content-area"></div>
<div id="auth-modal" class="modal" style="display:none; backdrop-filter: blur(15px);">
    <div class="modal-content" style="width: 350px; text-align: center;">
        <img src="LOGO.png" style="width: 150px; margin-bottom: 20px;">
        <div class="modal-header"><span id="auth-title">Login</span></div>
        <p id="auth-desc" style="font-size: 0.9em; color: #9e9e9e; margin-bottom: 20px;">Please login to access your library.</p>
        <div class="input-group" id="auth-url-group" style="display:none;"><label>Server URL</label><input type="text" id="auth-server-url" placeholder="http://192.168.1.100:1567"></div>
        <div class="input-group"><label>Username</label><input type="text" id="auth-username" placeholder="Username"></div>
        <div class="input-group"><label>Password</label><input type="password" id="auth-password" placeholder="Password"></div>
        <button id="handle-auth-btn" class="action-btn" style="width:100%">Login</button>
    </div>
</div>
<div id="settings-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header"><span>Settings</span><span class="close-btn" id="close-settings-btn">&times;</span></div>
        <div id="client-settings-area" style="display:none; border-top: 2px solid var(--accent); padding-top: 20px; margin-bottom: 25px;">
            <p style="font-size:1.1em; color:var(--accent); font-weight:bold; margin-bottom:10px;">Desktop Client Settings</p>
            <div class="input-group">
                <label style="display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="auto-sync-check" style="width:auto; margin-right:10px;"> Enable Auto-Sync Saves
                </label>
                <div style="font-size:0.8em; color:#999; margin-left:25px; line-height: 1.4;">
                    Automatically uploads local save changes to the cloud and downloads new saves from the server.<br>
                    ‚Ä¢ Creates local backups (.oldsave) before overwriting.<br>
                    ‚Ä¢ Maintains version history on the server.<br>
                    ‚Ä¢ Syncs automatically on startup and when files change.
                </div>
            </div>
            <div class="input-group"><label>Local Emulation Directory</label>
                <div style="display:flex; gap:10px;"><input type="text" id="client-local-dir" readonly style="flex:1;"><button id="select-local-dir-btn" class="action-btn">Browse</button></div>
            </div>
        </div>
        <button class="action-btn" id="auto-scan-btn" style="width:100%">‚ú® Auto Scan Missing Metadata</button>
    </div>
</div>
<div id="versions-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header"><span>Save Versions</span><span class="close-btn" id="close-versions-btn">&times;</span></div>
        <div id="versions-list" style="margin-top:20px;">Loading...</div>
    </div>
</div>
<div id="game-saves-modal" class="modal">
    <div class="modal-content" style="width: 760px; max-width: 95%;">
        <div class="modal-header"><span id="game-saves-title">Game Saves</span><span class="close-btn" id="close-game-saves-btn">&times;</span></div>
        <div id="game-saves-list" style="margin-top:20px;">Loading...</div>
    </div>
</div>
<div id="conflict-modal" class="modal">
    <div class="modal-content" style="width: 650px; max-width: 95%;">
        <div class="modal-header"><span>‚ö†Ô∏è Sync Conflicts</span></div>
        <p style="color:#ccc; font-size:0.9em; margin-bottom:20px; line-height: 1.5;">
            The following save files have been modified on both your local machine and the cloud since the last sync. 
            <br>Please choose which version you would like to keep.
        </p>
        <div id="conflict-list" style="display:flex; flex-direction:column; gap:15px; max-height:50vh; overflow-y:auto; margin-bottom:20px; padding-right: 5px;">
            <!-- Conflicts injected here -->
        </div>
        <div style="display:flex; justify-content:flex-end; gap:10px; border-top:1px solid #333; padding-top:15px;">
             <button class="action-btn" id="resolve-all-local" style="background:#3d5f7d; color:#ffffff; border:1px solid #4b6f8f; font-weight:700;">Keep All Local</button>
             <button class="action-btn" id="resolve-all-cloud" style="background:#285d49; color:#ffffff; border:1px solid #36735b; font-weight:700;">Keep All Cloud</button>
        </div>
    </div>
</div>
<div id="toast-container"></div>
<script>
(function() {
    const isElectron = !!(window.electronAPI);
    let serverUrl = '', localDir = '', sessionToken = localStorage.getItem('romstore_token') || '';
    let currentTab = 'games', rawData = [], activeFilters = new Set(), installedLocalPaths = new Set(), isGrouped = false, isSetupMode = false;
    let isListView = false, isAutoSync = false;
    let isAuthenticated = false;
    
    // Sync Manifest: Tracks last known state of files to detect conflicts
    let syncManifest = {};
    try { syncManifest = JSON.parse(localStorage.getItem('romstore_sync_manifest') || '{}'); } catch(e) { syncManifest = {}; }
    function updateManifest(relPath, lTime, sTime) {
        if (!relPath) return;
        syncManifest[relPath] = { l: lTime, s: sTime };
        localStorage.setItem('romstore_sync_manifest', JSON.stringify(syncManifest));
    }


    function getApiUrl(endpoint) {
        if (!isElectron) return endpoint;
        let base = serverUrl || '';
        if (base && !base.startsWith('http')) base = 'http://' + base;
        return base + endpoint;
    }
    function getFetchOptions(method, body) {
        const options = { method: method || 'GET', headers: {}, credentials: 'include' };
        if (sessionToken) options.headers['X-Session-Token'] = sessionToken;
        if (body) { options.headers['Content-Type'] = 'application/json'; options.body = JSON.stringify(body); }
        return options;
    }
    function showToast(message, type) {
        console.log('[Toast]', message);
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = 'toast ' + (type || 'info');
        toast.innerText = message;
        container.appendChild(toast);
        setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); }, 3000);
    }
    function normalizeTitle(value) {
        return (value || '')
            .toLowerCase()
            .replace(/^(wii|switch):\s*/i, '')
            .replace(/\s*\([a-z0-9]+\)\s*$/i, '')
            .replace(/[^a-z0-9]+/g, ' ')
            .trim();
    }
    function shouldSyncSavePath(relPath) {
        const p = String(relPath || '').replace(/\\/g, '/');
        if (!p) return false;

        const blockedPatterns = [
            /(^|\/)\.oldsave(\/|$)/i,
            /(^|\/)backup(\/|$)/i,
            /(^|\/)dolphin\/wii\/shared2\/sys(\/|$)/i,
            /(^|\/)dolphin\/wii\/shared2\/wc24(\/|$)/i,
            /(^|\/)dolphin\/wii\/sys(\/|$)/i,
            /(^|\/)dolphin\/wii\/title\/00000001\/00000002(\/|$)/i,
            /(^|\/)dolphin\/gc\/sram\.raw$/i,
            /(^|\/)dolphin\/wii\/fst\.bin$/i,
            /(^|\/)eden\/profiles(\/|$)/i,
            /(^|\/)ryujinx\/system(\/|$)/i,
            /(^|\/)ryujinx\/system_saves(\/|$)/i,
            /(^|\/)ryujinx\/savemeta(\/|$)/i,
            /(^|\/)es-de\/gamelists(\/|$)/i,
            /(^|\/)(prod|title)\.keys$/i,
            /(^|\/)profiles\.json$/i,
            /(^|\/)title\.tmd$/i,
            /(^|\/)banner\.bin$/i,
            /(^|\/)(loop_test|test_sync|testsave)\.sav$/i
        ];

        return !blockedPatterns.some(re => re.test(p));
    }
    async function enrichConflictMetadata(conflicts, serverSaves) {
        const byPath = new Map();
        serverSaves.forEach(s => byPath.set(s.relPath, s));

        let games = [];
        try {
            const gamesRes = await fetch(getApiUrl('/api/games'), getFetchOptions());
            if (gamesRes.ok) games = await gamesRes.json();
        } catch (e) {}

        const gameByNorm = new Map();
        games.forEach(g => {
            const norm = normalizeTitle(g.name);
            if (norm && !gameByNorm.has(norm)) gameByNorm.set(norm, g);
        });

        for (const c of conflicts) {
            const serverSave = byPath.get(c.path);
            if (!serverSave) continue;

            c.system = serverSave.system || 'Unknown';
            c.savePath = serverSave.relPath || c.path;
            c.displayName = serverSave.gameTitle || serverSave.name || c.path;

            const normSave = normalizeTitle(c.displayName);
            let matchedGame = gameByNorm.get(normSave);
            if (!matchedGame && normSave) {
                for (const g of games) {
                    const n = normalizeTitle(g.name);
                    if (!n) continue;
                    if (n.includes(normSave) || normSave.includes(n)) { matchedGame = g; break; }
                }
            }

            c.coverPath = matchedGame ? matchedGame.artworkPath : null;
            c.gameName = matchedGame ? matchedGame.name : c.displayName;
        }
    }
    async function scanLocalFiles() {
        if (isElectron && localDir) {
            console.log('[Local] Scanning:', localDir);
            const files = await window.electronAPI.scanLocalEmulation(localDir);
            installedLocalPaths = new Set(files);
            console.log('[Local] Found:', installedLocalPaths.size);
        }
    }
    async function checkAuth() {
        console.log('[Auth] Checking status...');
        if (isElectron) {
            document.getElementById('auth-url-group').style.display = 'block';
            document.getElementById('auth-server-url').value = serverUrl;
        }
        if (isElectron && !serverUrl) { document.getElementById('auth-modal').style.display = 'flex'; return; }
        try {
            const res = await fetch(getApiUrl('/api/auth/status'), getFetchOptions());
            const data = await res.json();
            if (data.needsSetup || !data.authenticated) {
                isAuthenticated = false;
                if (isElectron) window.electronAPI.stopSaveWatcher();
                document.getElementById('conflict-modal').style.display = 'none';
                if (!data.needsSetup && sessionToken) {
                    sessionToken = '';
                    localStorage.removeItem('romstore_token');
                }
                isSetupMode = !!data.needsSetup;
                const titleEl = document.getElementById('auth-title');
                if (titleEl) titleEl.innerText = isSetupMode ? 'Initial Setup' : 'Login';
                document.getElementById('auth-modal').style.display = 'flex';
            } else {
                isAuthenticated = true;
                document.getElementById('auth-modal').style.display = 'none';
                loadUIState();
                await scanLocalFiles();
                if (isAutoSync) toggleAutoSync(true);
                loadLibrary();
            }
        } catch (e) {
            console.error('[Auth] Status check failed', e);
            isAuthenticated = false;
            if (isElectron) window.electronAPI.stopSaveWatcher();
            document.getElementById('auth-modal').style.display = 'flex';
        }
    }
    async function handleAuth() {
        console.log('[Auth] Attempting login...');
        if (isElectron) {
            let inputUrl = document.getElementById('auth-server-url').value.trim();
            if (inputUrl) {
                if (!inputUrl.startsWith('http')) inputUrl = 'http://' + inputUrl;
                serverUrl = inputUrl;
                await window.electronAPI.saveConfig({ serverUrl, localDir });
            }
        }
        const username = document.getElementById('auth-username').value, password = document.getElementById('auth-password').value;
        if (!username || !password) return showToast('Fields required', 'error');
        try {
            const res = await fetch(getApiUrl(isSetupMode ? '/api/auth/setup' : '/api/auth/login'), getFetchOptions('POST', { username, password }));
            if (res.ok) {
                const data = await res.json();
                if (data.token) { sessionToken = data.token; localStorage.setItem('romstore_token', sessionToken); }
                isAuthenticated = true;
                showToast('Success!', 'success');
                document.getElementById('auth-modal').style.display = 'none';
                loadUIState();
                await scanLocalFiles();
                if (isAutoSync) toggleAutoSync(true);
                loadLibrary();
            } else showToast('Auth failed', 'error');
        } catch (e) { console.error('[Auth] Error:', e); showToast('Server error', 'error'); }
    }
    function saveUIState() { 
        localStorage.setItem('romstore_ui_state', JSON.stringify({ 
            currentTab, 
            activeFilters: Array.from(activeFilters), 
            isGrouped, 
            isListView,
            sortMode: document.getElementById('sort-select').value, 
            searchVal: document.getElementById('search-filter').value,
            installedOnly: document.getElementById('installed-only-filter').checked,
            isAutoSync
        })); 
    }
    function loadUIState() {
        const saved = localStorage.getItem('romstore_ui_state');
        if (!saved) return;
        try {
            const state = JSON.parse(saved);
            currentTab = state.currentTab || 'games'; activeFilters = new Set(state.activeFilters || []); isGrouped = !!state.isGrouped;
            isListView = !!state.isListView;
            isAutoSync = !!state.isAutoSync;
            document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
            const tb = document.getElementById('tab-' + currentTab); if (tb) tb.classList.add('active');
            document.getElementById('sort-select').value = state.sortMode || 'name_asc';
            document.getElementById('search-filter').value = state.searchVal || '';
            document.getElementById('installed-only-filter').checked = !!state.installedOnly;
            document.getElementById('group-toggle').classList.toggle('active', isGrouped);
            document.getElementById('view-toggle').classList.toggle('active', isListView);
            document.getElementById('auto-sync-check').checked = isAutoSync;
        } catch (e) {}
    }
    function toggleAutoSync(enable) {
        if (!isElectron) return;
        if (enable) {
            if (!isAuthenticated || !sessionToken) {
                showToast('Login required for auto-sync', 'error');
                document.getElementById('auto-sync-check').checked = false;
                isAutoSync = false;
                saveUIState();
                return;
            }
            const savesDir = localDir ? localDir + '/saves' : null;
            if (savesDir) {
                window.electronAPI.startSaveWatcher(savesDir);
                syncSaves(); // Trigger initial pull
            }
        } else {
            window.electronAPI.stopSaveWatcher();
        }
    }
    
    async function uploadSaveDirect(relPath) {
        if (!shouldSyncSavePath(relPath)) return false;
        const fullPath = `${localDir}/saves/${relPath}`;
        const res = await window.electronAPI.uploadSave(fullPath, relPath, sessionToken);
        if (res && res.success) {
            // Update manifest after successful upload
            const files = await window.electronAPI.scanDirStat(localDir + '/saves');
            const f = files.find(x => x.relPath === relPath);
            if (f) {
                const t = new Date(f.mtime).getTime();
                updateManifest(relPath, t, t); 
            }
            return true;
        }
        return false;
    }

    async function downloadSaveDirect(relPath) {
        if (!shouldSyncSavePath(relPath)) return;
        const dest = `${localDir}/saves/${relPath}`.split('\\').join('/');
        const url = getApiUrl(`/api/download?type=saves&path=${encodeURIComponent(relPath)}`);
        try {
            if (await window.electronAPI.checkLocalFile(dest)) {
                await window.electronAPI.backupLocalFile(dest);
            }
            await window.electronAPI.downloadFile(url, dest, sessionToken, relPath);
            
            // Update manifest after successful download
            // We need the server's mtime (or assume it's now synced). 
            // Better to re-scan local to get the exact mtime written to disk.
            const files = await window.electronAPI.scanDirStat(localDir + '/saves');
            const f = files.find(x => x.relPath === relPath);
            if (f) {
                const t = new Date(f.mtime).getTime();
                updateManifest(relPath, t, t);
            }
        } catch (e) { console.error('Download failed', e); }
    }

    async function syncSaves() {
        if (!isElectron || !localDir || !isAuthenticated || !sessionToken) return;
        console.log('[Sync] Starting conflict-aware sync...');
        showToast('Checking for cloud saves...', 'info');
        const timeToleranceMs = 120000; // tolerate small cloud/local mtime skew
        
        try {
            const res = await fetch(getApiUrl('/api/saves'), getFetchOptions());
            if (res.status === 401) {
                isAuthenticated = false;
                window.electronAPI.stopSaveWatcher();
                document.getElementById('auth-modal').style.display = 'flex';
                return;
            }
            if (!res.ok) throw new Error('Failed to fetch server saves');
            const serverSaves = await res.json();
            const localSaves = (await window.electronAPI.scanDirStat(localDir + '/saves'))
                .filter(l => shouldSyncSavePath(l.relPath));
             
            const serverMap = new Map();
            serverSaves
                .filter(s => shouldSyncSavePath(s.relPath))
                .forEach(s => serverMap.set(s.relPath, new Date(s.mtime).getTime()));
            
            const localMap = new Map();
            localSaves.forEach(l => localMap.set(l.relPath, new Date(l.mtime).getTime()));

            const allPaths = new Set([...serverMap.keys(), ...localMap.keys()]);
            const conflicts = [];
            let dlCount = 0, ulCount = 0;

            for (const path of allPaths) {
                const sTime = serverMap.get(path);
                const lTime = localMap.get(path);
                const manifest = syncManifest[path]; 

                // 1. New on Server (Missing Local) -> Download
                if (lTime === undefined && sTime !== undefined) {
                    if (!manifest || !manifest.l) { // If never seen locally, download
                         console.log('[Sync] New on server:', path);
                         await downloadSaveDirect(path); dlCount++;
                    } else {
                         // Was deleted locally? If manifest says we had it.
                         // For now, re-download to be safe, or ignore? 
                         // Steam usually re-downloads unless you explicitly deleted it.
                         await downloadSaveDirect(path); dlCount++;
                    }
                    continue;
                }

                // 2. New on Local (Missing Server) -> Upload
                if (sTime === undefined && lTime !== undefined) {
                    if (!manifest || !manifest.s) {
                        console.log('[Sync] New on local:', path);
                        await uploadSaveDirect(path); ulCount++;
                    }
                    // If it was on server (manifest.s exists) but is gone now?
                    // Re-upload.
                    continue;
                }

                // 3. Exists on Both -> Check Changes
                const lastL = manifest ? manifest.l : 0;
                const lastS = manifest ? manifest.s : 0;
                
                // Allow tolerance for filesystem timestamp precision and network copy drift
                const localChanged = lTime !== undefined && Math.abs(lTime - lastL) > timeToleranceMs;
                const serverChanged = sTime !== undefined && Math.abs(sTime - lastS) > timeToleranceMs;
                
                // No Manifest (First Run)
                if (!manifest) {
                    if (Math.abs(lTime - sTime) <= timeToleranceMs) {
                        updateManifest(path, lTime, sTime); // close enough, treat as synced
                    } else if (sTime > lTime) {
                        await downloadSaveDirect(path); dlCount++;
                    } else if (lTime > sTime) {
                        await uploadSaveDirect(path); ulCount++;
                    } else {
                        updateManifest(path, lTime, sTime);
                    }
                    continue;
                }

                if (localChanged && serverChanged) {
                    // Both changed but nearly same timestamp: assume same logical save state.
                    if (Math.abs(lTime - sTime) <= timeToleranceMs) {
                        updateManifest(path, lTime, sTime);
                    } else {
                        conflicts.push({ path, lTime, sTime });
                    }
                } else if (localChanged) {
                    console.log('[Sync] Local changed:', path);
                    await uploadSaveDirect(path); ulCount++;
                } else if (serverChanged) {
                    console.log('[Sync] Server changed:', path);
                    await downloadSaveDirect(path); dlCount++;
                }
            }

            if (conflicts.length > 0) {
                await enrichConflictMetadata(conflicts, serverSaves);
                await showConflictModal(conflicts);
            } else if (dlCount > 0 || ulCount > 0) {
                showToast(`Sync: ${dlCount} ‚Üì, ${ulCount} ‚Üë`, 'success');
            } else {
                console.log('[Sync] Up to date');
                showToast('Saves are up to date', 'info');
            }
            
        } catch (e) {
            console.error('[Sync] Error:', e);
            showToast('Sync check failed', 'error');
        }
    }

    async function showConflictModal(conflicts) {
        const modal = document.getElementById('conflict-modal');
        const list = document.getElementById('conflict-list');
        list.innerHTML = '';
        
        for (const c of conflicts) {
            const item = document.createElement('div');
            item.className = 'conflict-item';
            
            const lDate = new Date(c.lTime);
            const sDate = new Date(c.sTime);
            const lNewer = c.lTime > c.sTime;
            const coverUrl = c.coverPath ? await getAuthImg(c.coverPath) : null;
            
            item.innerHTML = `
                <div style="display:flex; gap:12px; align-items:flex-start;">
                    ${coverUrl
                        ? `<img src="${coverUrl}" style="width:72px;height:96px;object-fit:cover;border-radius:6px;border:1px solid rgba(255,255,255,0.15);">`
                        : `<div style="width:72px;height:96px;border-radius:6px;background:#1a2d42;display:flex;align-items:center;justify-content:center;font-size:28px;">üéÆ</div>`
                    }
                    <div style="flex:1;">
                        <div class="conflict-title">${c.gameName || c.displayName || c.path}</div>
                        <div style="font-size:0.8em; color:#9fb2c9; margin-bottom:8px;">${c.system || 'System'} save ‚Ä¢ ${c.savePath || c.path}</div>
                    </div>
                </div>
                <div class="conflict-compare">
                    <div class="conflict-side local">
                        <div class="c-label">Local Device</div>
                        <div class="c-date">${lDate.toLocaleDateString()} ${lDate.toLocaleTimeString()}</div>
                        <div class="c-badge ${lNewer ? 'c-newer' : 'c-older'}">${lNewer ? 'NEWER' : 'OLDER'}</div>
                    </div>
                    <div class="conflict-side cloud">
                        <div class="c-label">Cloud Save</div>
                        <div class="c-date">${sDate.toLocaleDateString()} ${sDate.toLocaleTimeString()}</div>
                        <div class="c-badge ${!lNewer ? 'c-newer' : 'c-older'}">${!lNewer ? 'NEWER' : 'OLDER'}</div>
                    </div>
                </div>
                <div class="conflict-actions">
                    <button class="action-btn-small" style="background:#2a4458; color:#ffffff; border:1px solid #40637e;" onclick="resolveConflict('${c.path}', 'local')">Keep Local</button>
                    <button class="action-btn-small" style="background:#2f5b3f; color:#ffffff; border:1px solid #3e7954;" onclick="resolveConflict('${c.path}', 'cloud')">Keep Cloud</button>
                </div>
            `;
            list.appendChild(item);
        }

        document.getElementById('resolve-all-local').onclick = () => resolveAll(conflicts, 'local');
        document.getElementById('resolve-all-cloud').onclick = () => resolveAll(conflicts, 'cloud');
        
        modal.style.display = 'flex';
    }

    window.resolveConflict = async (path, choice) => {
        const item = document.querySelector(`.conflict-item:has(.conflict-title)`); // messy selector, better to rebuild list
        // Actually, just perform action and remove from DOM or refresh
        document.getElementById('conflict-modal').style.display = 'none'; // Close for now, or refresh
        showToast(`Resolving ${path}...`, 'info');
        
        if (choice === 'local') await uploadSaveDirect(path);
        else await downloadSaveDirect(path);
        
        // Re-run sync to check remaining or verify
        setTimeout(syncSaves, 500);
    };

    window.resolveAll = async (conflicts, choice) => {
        document.getElementById('conflict-modal').style.display = 'none';
        showToast(`Resolving all ${conflicts.length} conflicts...`, 'info');
        for (const c of conflicts) {
            if (choice === 'local') await uploadSaveDirect(c.path);
            else await downloadSaveDirect(c.path);
        }
        showToast('All conflicts resolved', 'success');
    };


    async function loadLibrary() {
        console.log('[Library] Loading', currentTab);
        const content = document.getElementById('main-content'); content.innerHTML = 'Scanning...';
        try {
            const res = await fetch(getApiUrl('/api/' + currentTab), getFetchOptions());
            if (res.status === 401) return checkAuth();
            const data = await res.json();
            rawData = data.map(item => { if (!item.system) item.system = item.relPath.split('/')[0] || 'Unknown'; return item; });
            renderFilters(); await renderContent();
        } catch (err) { console.error('[Library] Load failed', err); content.innerHTML = '<div style="color:red">Error: ' + err.message + '</div>'; }
    }
    async function getAuthImg(path) {
        try {
            const res = await fetch(getApiUrl('/api/artwork?path=' + encodeURIComponent(path)), getFetchOptions());
            if (!res.ok) return null;
            return URL.createObjectURL(await res.blob());
        } catch (e) { return null; }
    }
    async function createCard(item) {
        const card = document.createElement('div');
        const typePrefix = currentTab === 'installed' ? (item._type + '/') : (currentTab === 'games' ? 'roms/' : currentTab + '/');
        const isLocal = installedLocalPaths.has(typePrefix + item.relPath);
        card.className = 'game-card';
        card.dataset.relPath = item.relPath; 
        let imgUrl = null; if (item.artworkPath) imgUrl = await getAuthImg(item.artworkPath);
        const title = (currentTab === 'saves' && item.gameTitle) ? item.gameTitle : item.name;
        
        let actionBtn = `<button class="action-btn-small dl-btn">Download</button>`;
        if (isLocal) {
            actionBtn = `<button class="action-btn-small uninstall-btn" style="background-color: #f44336; color: white;">Uninstall</button>`;
        }
        let versionsBtn = '';
        if (currentTab === 'saves' || item._type === 'saves') {
            versionsBtn = `<button class="action-btn-small versions-btn" style="background:#555; margin-top:5px;">History</button>`;
        }
        const gameSavesBtn = currentTab === 'games'
            ? `<button class="action-btn-small game-saves-btn" style="background:#2f1d10; color:#ffd8be; margin-top:5px; border:1px solid #6e3c1d;">Game Saves</button>`
            : '';

        card.innerHTML = `
            <div class="art-wrapper">
                ${imgUrl ? `<img src="${imgUrl}" class="game-art">` : `<div class="icon-placeholder">${currentTab === 'saves' ? 'üíæ' : 'üíø'}</div>`}
                <div class="card-overlay">
                    <div class="overlay-info"><div class="overlay-system">${item.system}</div><div class="overlay-meta">Size: ${item.size}</div></div>
                    ${isLocal ? '<span style="color:var(--success); font-weight:bold; margin-bottom:5px;">‚úì Installed</span>' : ''}
                    ${actionBtn}
                    ${versionsBtn}
                    ${gameSavesBtn}
                </div>
            </div>
            <div class="progress-container"><div class="progress-bar"></div></div>
            <div class="game-title-below">${title}</div>`;
        card.onclick = e => { if (e.target.tagName !== 'BUTTON') card.classList.toggle('active'); };
        if (isLocal) {
            card.querySelector('.uninstall-btn').onclick = e => { e.stopPropagation(); uninstallGame(item); };
        } else {
            card.querySelector('.dl-btn').onclick = e => { e.stopPropagation(); startDownload(item); };
        }
        if (versionsBtn) card.querySelector('.versions-btn').onclick = e => { e.stopPropagation(); showVersions(item); };
        if (gameSavesBtn) card.querySelector('.game-saves-btn').onclick = e => { e.stopPropagation(); showGameSaves(item); };
        return card;
    }
    async function createRow(item) {
        const row = document.createElement('div');
        const typePrefix = currentTab === 'installed' ? (item._type + '/') : (currentTab === 'games' ? 'roms/' : currentTab + '/');
        const isLocal = installedLocalPaths.has(typePrefix + item.relPath);
        row.className = 'game-row';
        row.dataset.relPath = item.relPath;
        let imgUrl = null; if (item.artworkPath) imgUrl = await getAuthImg(item.artworkPath);
        const title = (currentTab === 'saves' && item.gameTitle) ? item.gameTitle : item.name;
        
        let actionBtn = `<button class="action-btn-small dl-btn">Download</button>`;
        if (isLocal) {
            actionBtn = `<button class="action-btn-small uninstall-btn" style="background-color: #f44336; color: white;">Uninstall</button>`;
        }
        let versionsBtn = '';
        if (currentTab === 'saves' || item._type === 'saves') {
            versionsBtn = `<button class="action-btn-small versions-btn" style="background:#555; margin-left:10px;">History</button>`;
        }
        const gameSavesBtn = currentTab === 'games'
            ? `<button class="action-btn-small game-saves-btn" style="background:#2f1d10; color:#ffd8be; margin-left:10px; border:1px solid #6e3c1d;">Game Saves</button>`
            : '';

        row.innerHTML = `
            ${imgUrl ? `<img src="${imgUrl}" class="row-thumb">` : `<div class="row-thumb" style="display:flex;align-items:center;justify-content:center;font-size:24px;">üíø</div>`}
            <div class="row-info">
                <div class="row-title">${title}</div>
                <div class="row-meta"><span>${item.system}</span><span>‚Ä¢</span><span>${item.size}</span></div>
                <div class="progress-container"><div class="progress-bar"></div></div>
            </div>
            <div class="row-actions">
                ${isLocal ? '<span style="color:var(--success); font-weight:bold;">‚úì</span>' : ''}
                ${actionBtn}
                ${versionsBtn}
                ${gameSavesBtn}
            </div>`;
        row.onclick = e => { if (e.target.tagName !== 'BUTTON') row.classList.toggle('active'); };
        if (isLocal) {
            row.querySelector('.uninstall-btn').onclick = e => { e.stopPropagation(); uninstallGame(item); };
        } else {
            row.querySelector('.dl-btn').onclick = e => { e.stopPropagation(); startDownload(item); };
        }
        if (versionsBtn) row.querySelector('.versions-btn').onclick = e => { e.stopPropagation(); showVersions(item); };
        if (gameSavesBtn) row.querySelector('.game-saves-btn').onclick = e => { e.stopPropagation(); showGameSaves(item); };
        return row;
    }
    async function uninstallGame(item) {
        if (!confirm('Are you sure you want to uninstall ' + item.name + '?')) return;
        const type = currentTab === 'installed' ? item._type : (currentTab === 'games' ? 'roms' : currentTab);
        const dest = localDir ? `${localDir}/${type}/${item.relPath}`.split('\\').join('/') : null;
        if (isElectron && dest) {
            const success = await window.electronAPI.deleteFile(dest);
            if (success) {
                showToast('Uninstalled', 'success');
                await scanLocalFiles();
                await renderContent();
            } else {
                showToast('Uninstall failed', 'error');
            }
        }
    }
    async function startDownload(item, version = null, forcedType = null) {
        const type = forcedType || (currentTab === 'installed' ? item._type : (currentTab === 'games' ? 'roms' : currentTab));
        const dest = localDir ? `${localDir}/${type}/${item.relPath}`.split('\\').join('/') : null;
        if (isElectron && !dest) return showToast('Set local directory in Settings', 'error');
        
        if (isElectron && version) {
             // Backup before version restore
             await window.electronAPI.backupLocalFile(dest);
             showToast('Local backup created', 'info');
        }

        showToast('Downloading...', 'info');
        try {
            const url = getApiUrl(`/api/download?type=${type}&path=${encodeURIComponent(item.relPath)}`);
            if (isElectron) {
                await window.electronAPI.downloadFile(url, dest, sessionToken, item.relPath);
                showToast('Done!', 'success'); await scanLocalFiles(); await renderContent();
            } else { window.open(url, '_blank'); }
        } catch (e) { showToast('Download failed', 'error'); }
    }
    async function showGameSaves(game) {
        document.getElementById('game-saves-modal').style.display = 'flex';
        document.getElementById('game-saves-title').innerText = `Saves for ${game.name}`;
        const list = document.getElementById('game-saves-list');
        list.innerHTML = 'Loading save files...';
        try {
            const res = await fetch(getApiUrl(`/api/game-saves?relPath=${encodeURIComponent(game.relPath)}`), getFetchOptions());
            if (!res.ok) {
                const raw = await res.text();
                let message = 'Failed to load game saves';
                try {
                    const parsed = JSON.parse(raw);
                    if (parsed && parsed.error) message = parsed.error;
                } catch (e) {
                    if (raw && raw.trim().startsWith('<')) {
                        message = 'Server returned HTML instead of JSON. Restart backend/frontend with latest code.';
                    } else if (raw && raw.trim()) {
                        message = raw.trim();
                    }
                }
                throw new Error(message);
            }
            const saves = await res.json();
            if (saves.length === 0) {
                list.innerHTML = '<div style="color:#9fb2c9;">No matching saves found for this game.</div>';
                return;
            }
            list.innerHTML = '';
            saves.forEach(save => {
                const row = document.createElement('div');
                row.className = 'version-row';
                row.innerHTML = `
                    <div class="version-info">
                        <div style="font-weight:600; color:#fff;">${save.relPath}</div>
                        <div style="font-size:0.8em; color:#9fb2c9;">Updated: ${new Date(save.mtime).toLocaleString()}</div>
                        <div style="font-size:0.8em; color:#9fb2c9;">Versions: ${save.versionsCount || 0}</div>
                    </div>
                    <div style="display:flex; gap:8px;">
                        <button class="action-btn-small dl-save-btn">Download</button>
                        <button class="action-btn-small history-btn" style="background:#3a566f; color:#dbeeff;">History</button>
                    </div>
                `;
                row.querySelector('.dl-save-btn').onclick = () => startDownload(save, null, 'saves');
                row.querySelector('.history-btn').onclick = () => showVersions(save);
                list.appendChild(row);
            });
        } catch (e) {
            list.innerHTML = `<div style="color:#ff8f8f;">${e.message}</div>`;
        }
    }
    async function showVersions(item) {
        document.getElementById('versions-modal').style.display = 'flex';
        const list = document.getElementById('versions-list');
        list.innerHTML = 'Loading versions...';
        try {
            const res = await fetch(getApiUrl(`/api/saves/versions?relPath=${encodeURIComponent(item.relPath)}`), getFetchOptions());
            const versions = await res.json();
            if (versions.length === 0) { list.innerHTML = 'No history available.'; return; }
            list.innerHTML = '';
            versions.forEach(v => {
                const row = document.createElement('div'); row.className = 'version-row';
                const date = new Date(v.time).toLocaleString();
                row.innerHTML = `<div class="version-info"><div>${date}</div><div style="font-size:0.8em">${v.name}</div></div>
                                 <button class="action-btn-small restore-btn">Restore</button>`;
                row.querySelector('.restore-btn').onclick = () => restoreVersion(item, v.name);
                list.appendChild(row);
            });
        } catch (e) { list.innerHTML = 'Error loading versions.'; }
    }
    async function restoreVersion(item, versionName) {
        if (!confirm('Restore this version? Current server version will be backed up.')) return;
        try {
            // 1. Tell server to make this version current
            const res = await fetch(getApiUrl('/api/saves/restore'), getFetchOptions('POST', { relPath: item.relPath, versionName }));
            if (!res.ok) throw new Error('Server restore failed');
            // 2. Download the new current version
            await startDownload(item, versionName, 'saves'); 
            document.getElementById('versions-modal').style.display = 'none';
        } catch (e) { showToast('Restore failed', 'error'); }
    }
    function renderFilters() {
        const c = document.getElementById('filter-container'); if (!c) return; c.innerHTML = '';
        const sys = Array.from(new Set(rawData.map(i => i.system))).sort();
        const chip = (txt, active, onClick) => { const d = document.createElement('div'); d.className = 'filter-chip ' + (active ? 'active' : ''); d.innerText = txt; d.onclick = onClick; c.appendChild(d); };
        chip('All Systems', activeFilters.size === 0, () => { activeFilters.clear(); renderFilters(); renderContent(); });
        sys.forEach(s => chip(s, activeFilters.has(s), () => { if (activeFilters.has(s)) activeFilters.delete(s); else activeFilters.add(s); renderFilters(); renderContent(); }));
    }
    async function renderContent() {
        const c = document.getElementById('main-content'); c.innerHTML = '';
        let filtered = [...rawData];
        if (activeFilters.size > 0) filtered = filtered.filter(i => activeFilters.has(i.system));
        
        if (document.getElementById('installed-only-filter').checked) {
             filtered = filtered.filter(item => {
                 const typePrefix = currentTab === 'installed' ? (item._type + '/') : (currentTab === 'games' ? 'roms/' : currentTab + '/');
                 return installedLocalPaths.has(typePrefix + item.relPath);
             });
        }

        const search = document.getElementById('search-filter').value.toLowerCase();
        if (search) filtered = filtered.filter(i => (i.gameTitle || i.name).toLowerCase().includes(search));
        
        // Sorting Logic
        const sortMode = document.getElementById('sort-select').value;
        filtered.sort((a, b) => {
            if (sortMode === 'name_asc') return (a.gameTitle || a.name).localeCompare(b.gameTitle || b.name);
            if (sortMode === 'name_desc') return (b.gameTitle || b.name).localeCompare(a.gameTitle || a.name);
            if (sortMode === 'date_new') return new Date(b.mtime) - new Date(a.mtime);
            if (sortMode === 'date_old') return new Date(a.mtime) - new Date(b.mtime);
            return 0;
        });

        if (filtered.length === 0) { c.innerHTML = '<div style="text-align:center; padding:20px;">No items found</div>'; return; }
        
        const renderGroup = async (items) => {
            const container = document.createElement('div');
            container.className = isListView ? 'library-list' : 'library-grid';
            const elements = await Promise.all(items.map(isListView ? createRow : createCard));
            elements.forEach(el => container.appendChild(el));
            return container;
        };

        if (isGrouped) {
            const groups = {};
            filtered.forEach(item => {
                if (!groups[item.system]) groups[item.system] = [];
                groups[item.system].push(item);
            });
            const systems = Object.keys(groups).sort();
            for (const system of systems) {
                const header = document.createElement('div');
                header.className = 'section-header';
                header.innerText = system;
                c.appendChild(header);
                c.appendChild(await renderGroup(groups[system]));
            }
        } else {
            c.appendChild(await renderGroup(filtered));
        }
    }
    function changeTab(t) { currentTab = t; document.querySelectorAll('.tabs button').forEach(b => b.classList.toggle('active', b.id === 'tab-'+t)); activeFilters.clear(); document.getElementById('search-filter').value = ''; saveUIState(); loadLibrary(); }

    document.addEventListener('DOMContentLoaded', async () => {
        document.getElementById('logout-btn').onclick = async () => {
            if (isElectron) await window.electronAPI.stopSaveWatcher();
            localStorage.removeItem('romstore_token');
            sessionToken = '';
            isAuthenticated = false;
            location.reload();
        };
        document.getElementById('handle-auth-btn').onclick = handleAuth;
        document.getElementById('open-settings-btn').onclick = () => { document.getElementById('settings-modal').style.display = 'flex'; };
        document.getElementById('close-settings-btn').onclick = () => { document.getElementById('settings-modal').style.display = 'none'; };
        document.getElementById('close-versions-btn').onclick = () => { document.getElementById('versions-modal').style.display = 'none'; };
        document.getElementById('close-game-saves-btn').onclick = () => { document.getElementById('game-saves-modal').style.display = 'none'; };
        document.getElementById('settings-modal').onclick = (e) => { if(e.target === document.getElementById('settings-modal')) document.getElementById('settings-modal').style.display = 'none'; };
        document.getElementById('versions-modal').onclick = (e) => { if(e.target === document.getElementById('versions-modal')) document.getElementById('versions-modal').style.display = 'none'; };
        document.getElementById('game-saves-modal').onclick = (e) => { if(e.target === document.getElementById('game-saves-modal')) document.getElementById('game-saves-modal').style.display = 'none'; };
        document.getElementById('conflict-modal').onclick = (e) => { if(e.target === document.getElementById('conflict-modal')) document.getElementById('conflict-modal').style.display = 'none'; };
        document.getElementById('tab-games').onclick = () => { changeTab('games'); };
        document.getElementById('tab-bios').onclick = () => { changeTab('bios'); };
        document.getElementById('search-filter').oninput = () => { saveUIState(); renderContent(); };
        document.getElementById('sort-select').onchange = () => { saveUIState(); renderContent(); };
        document.getElementById('installed-only-filter').onchange = () => { saveUIState(); renderContent(); };
        document.getElementById('group-toggle').onclick = function() { isGrouped = !isGrouped; this.classList.toggle('active', isGrouped); saveUIState(); renderContent(); };
        document.getElementById('view-toggle').onclick = function() { isListView = !isListView; this.classList.toggle('active', isListView); saveUIState(); renderContent(); };
        
        const autoSyncCheck = document.getElementById('auto-sync-check');
        autoSyncCheck.onchange = () => {
             isAutoSync = autoSyncCheck.checked;
             toggleAutoSync(isAutoSync);
             saveUIState();
        };

        if (isElectron) {
            document.getElementById('client-settings-area').style.display = 'block';
            document.getElementById('select-local-dir-btn').onclick = async () => {
                const p = await window.electronAPI.selectDir(); 
                if (p) { localDir = p; document.getElementById('client-local-dir').value = p; await window.electronAPI.saveConfig({ serverUrl, localDir }); await scanLocalFiles(); renderContent(); }
            };
            const cfg = await window.electronAPI.getConfig(); serverUrl = cfg.serverUrl || ''; localDir = cfg.localDir || ''; document.getElementById('client-local-dir').value = localDir;
            
            window.electronAPI.onDownloadProgress((event, { relPath, percent }) => {
                const el = document.querySelector(`[data-rel-path="${relPath}"]`);
                if (el) {
                    el.classList.add('downloading');
                    const bar = el.querySelector('.progress-bar');
                    if (bar) bar.style.width = percent + '%';
                    if (percent >= 100) {
                        setTimeout(() => { el.classList.remove('downloading'); scanLocalFiles().then(renderContent); }, 1000);
                    }
                }
            });
            
            window.electronAPI.onSaveChange(async (event, { relPath, fullPath }) => {
                if (!isAuthenticated || !sessionToken || !isAutoSync) return;
                if (!shouldSyncSavePath(relPath)) return;
                console.log('[AutoSync] Change detected:', relPath);
                showToast('Syncing save...', 'info');
                // We need sessionToken here.
                const result = await window.electronAPI.uploadSave(fullPath, relPath, sessionToken);
                
                const isSuccess = (typeof result === 'object' && result !== null) ? result.success : result;
                const errorMsg = (typeof result === 'object' && result !== null && result.error) ? ': ' + result.error : '';

                if (isSuccess) showToast('Save Synced!', 'success');
                else showToast('Sync failed' + errorMsg, 'error');
            });
        }
        checkAuth();
    });
})();
</script>
</body>
</html>



